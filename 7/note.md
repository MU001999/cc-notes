**疑问**

1. P130, 最后一段，为什么 $X$ 是**实**变量矩阵？下文中从 $[2n]$ 为 $x_{i,j}$ 选择值，难道 $[2n]$ 是实数集吗？是的话它的长度也是 $2n$ 吗？

# 7 - 随机计算

之前使用图灵机作为计算的标准模型，但图灵机似乎没有在计算中进行随机选择的能力（大多数编程语言提供一个内建的随机数生成器，尽管通常是伪随机的）。值得考虑可以掷硬币的算法，即使用一个随机比特串的源。

经典统计中的民意测验等，尝试通过全体居民随机的小样本，来估计关于全体居民的事实。随机也是模拟现实世界系统的自然工具，这些系统本身就是概率性的。

本章不讨论随机数生成器的质量问题，而是关注能够随意掷硬币的图灵机的能力。

## 7.1 概率图灵机

随机算法是可能涉及随机选择（比如用从某个范围随机选择的整数初始化变量）的算法。实际上，随机算法是用随机数生成器实现的，而事实上，有一个能够生成随机比特串的随机数生成器就足够了，即以 $1/2$ 的概率生成 0，以 $1/2$ 的概率生成 1 的生成器。通常描述这样的生成器为掷公平硬币。

为了建模随机算法，使用概率图灵机：

<img src="note.assets/image-20210508132612511.png" alt="image-20210508132612511" style="zoom: 67%;" />

需要注意，其中 PTM 的运行时间与进行的随机选择无关。

回顾 NDTM，同样是有两个转移函数的图灵机，因此 PTM 和 NDTM 是句法相似的（我理解是表示（对规则的描述）相似），区别在于如何解释图灵机的运行。NDTM 当存在输出 1 的路径时接受输入；而 PTM 考虑这种情况的分支的分数，也即 ${\rm Pr}[M(x)=1]$。概念上，PTM 更像 DTM 而非 NDTM，旨在模拟真实的计算设备。

使用类 ${\bf BPP}$ （bounded-error probabilistic polynomial-time）捕获高效的概率计算。对 $L\sube\{0,1\}^*$ 和 $x\in\{0,1\}^*$，定义 $L(x)=1$ 如果 $x\in L$，否则 $L(x)=0$。

<img src="note.assets/image-20210508132647720.png" alt="image-20210508132647720" style="zoom: 67%;" />

其中常数 $2/3$ 被替换为任意大于 $1/2$ 的数都不会改变 BPTIME 和 BPP，还可以允许不公平的硬币投掷（即选择概率的概率不为 $1/2$），以及允许运行是期望的多项式时间。

根据 BPP 的定义，对于每个输入，M 输出正确结果的概率都需要至少为 $2/3$，因此 BPP 类似 P，仍然是捕获最坏情况下复杂性的类。而 DTM 是 PTM 的一个特殊情况，因此类 ${\bf BPP}$ 包含 ${\bf P}$。

类似 NP，也可以使用 DTM 定义 BPP，将掷硬币的过程作为一个额外输入：

<img src="note.assets/image-20210508142316582.png" alt="image-20210508142316582" style="zoom:67%;" />

显然 ${\bf BPP}\sube{\bf EXP}$，因为指数时间内可以枚举多项式时间 PTM 的所有可能的随机选择。当前研究者只知道 ${\bf BPP}$ 位于 ${\bf P}$ 和 ${\bf EXP}$ 之间，甚至不能证明 ${\bf BPP}$ 是不是 ${\bf NEXP}$ 的真子集。

一个核心的未决问题是，${\bf BPP}={\bf P}$ 是否成立，许多复杂性理论家相信 ${\bf BPP}={\bf P}$，也即存在转换每个概率算法到一个确定算法的方法，同时只导致多项式的减速。

## 7.2 一些 PTM 的例子

> PTM 实例而非 BPP

### 7.2.1 查找中位数

查找第 $k$ 小的数：

<img src="note.assets/image-20210508183753819.png" alt="image-20210508183753819" style="zoom:67%;" />

时间复杂度是 $O(n)$ 的。

### 7.2.2 概率素数检测

素数检测即给定一个整数 $N$，判断它是否是素数。由素数组成的语言 PRIMES：

<img src="note.assets/image-20210508190017980.png" alt="image-20210508190017980" style="zoom:67%;" />

对任意数 $N$，以及 $A\in[N-1]$，定义

<img src="note.assets/image-20210508203151275.png" alt="image-20210508203151275" style="zoom:67%;" />

有以下事实：

<img src="note.assets/image-20210508203322173.png" alt="image-20210508203322173" style="zoom:67%;" />

可以得到算法：对于一个随机的 $1\le A<N$，如果 $gcd(N,A)>1$ 或 $(\frac{N}{A})\neq A^{(N-1)/2}$，则判断 $N$ 为合数；否则认为 $N$ 是素数。因为如果 $N$ 是素数，则一定满足 $gcd(N,A)=1$ 和 $(\frac{N}{A})=A^{(N-1)/2}$；而对于奇合数 $N$，当 $gcd(N,A)=1$ 时，仅有最多一半的 $A$ 能够令 $(\frac{N}{A})=A^{(N-1)/2}$，因此合数同时满足这两个条件的概率大于 $1/2$，而这个概率可以通过重复测试来放大。

### 7.2.3 多项式恒等检测

即给出一个以隐含形式定义的有整数系数的多项式，判定这个多项式是否恒等于零。

假设得到了代数电路形式（类似布尔电路，但运算为 $+,-,*$ 而非 $\and,\or,\neg$）的多项式，代数电路定义了一个由 $\mathbb{Z}^n$ 到 $\mathbb{Z}$ 的多项式，通过将输入放置在源节点上，并用对应的运算计算每个节点的值。定义 ZEROP 为计算恒等于零的多项式的代数电路的集合。判定 ZEROP 的成员也被称为多项式恒等检测，因为判断多项式 $C$ 和 $C'$ 是否恒等可以由 $D=C-C'$ 是否恒等于零完成。

而用于检验 ZEROP 成员的算法需要用到 Schwartz-Zippel Lemma：

<img src="note.assets/image-20210509094630024.png" alt="image-20210509094630024" style="zoom:67%;" />

该引理表明，由多项式的总次数 $d$ 和输入的取值集合的大小 $|S|$ 可以得到多项式的值不为零的概率下界，同时可以得到多项式取值为零的概率上届，即 $\cfrac{d}{|S|}$。以一元多项式为例，$d$ 次一元多项式最多 $d$ 个根，而 $x$ 从 $S$ 中选取，因此 $Pr[p(x)]=0\le\cfrac{d}{|S|}$。

一个大小为 $m$ 的电路 $C$ 可以包含最多 $m$ 个乘法，即定义一个次数最多为 $2^m$ 的多项式，比如：

![image-20210509095922083](note.assets/image-20210509095922083.png)

因此可以得到一个简单的概率算法：从 1 到 $10*2^m$ 中选择 $n$ 个数 $x_1,...,x_n$，求电路 $C$ 在 $x_1,...,x_n$ 上的值 $y$，如果 $y=0$ 则接受，否则拒绝。显然如果 $C\in{\rm ZEROP}$，则总是接受。而如果 $C\notin{\rm ZEROP}$，至少有 $9/10$ 的概率会拒绝。因为 $d<2^m$，而 $|S|=10*2^m$，因此 $Pr(p\neq0)\ge\cfrac{9}{10}$。

但是这个算法存在一个问题，输出的大小可能为 $(10*2^m)^{2^m}$，即 $2^m$ 个 $10*2^m$ 相乘。可以通过一个称为指纹的技术解决这一问题，即在求值时模 $k$，$k$ 在 $[2^{2m}]$ 中随机选择，最后计算的值为 $y\ (mod\ k)$，显然如果 $y=0$，则 $y\ (mod\ k)$=0，而如果 $y\neq0$，则 $k$ 至少有 $\delta=\frac{1}{4m}$ 的概率不整除 $y$，这个概率足够了，因为可以通过重复这个过程 $O(1/\delta)$ 次，并且只有所有的输出都为 0 才接受（时间换空间）。

假设 $y\neq0$，令 $\mathcal{B}=\{p_1,...,p_{\mathcal{l}}\}$ 表示 $y$ 的不同的质因子，$k$ 是质数但不在 $\mathcal{B}$ 中的概率至少为 $\delta$。根据质数定理，对于足够大的 $m$，$[2^{2m}]$ 中的质数至少有 $\frac{2^{2m}}{2m}$ 个，因为 $y\le(10*2^m)^{2^m}$，因此 $y$ 至多有 ${\rm log}y\le5m2^m=o(\frac{2^{2m}}{2m})$ 个质因子，是 $\frac{2^{2m}}{2m}$ 的高阶无穷小，因此 $[2^{2m}]$ 中不在 $\mathcal{B}$ 中的质数至少有 $\frac{2^{2m}}{4m}$ 个，因此 $k$ 不能整除 $y$ 的概率至少有 $\delta=\frac{1}{4m}$。

### 7.2.4 二分图完备匹配检测

令 $G=(V,E)$ 是一个二分图，其中 $V$ 可以分成两个大小相同的不相交子集 $V_1,V_2$，即 $V=V_1\cup V_2$，并有 $E\sube V_1\times V_2$，即 $G$ 中的每一个边的两个顶点都分别属于 $V_1$ 和 $V_2$。$G$ 中的一个完备匹配是边的一个子集 $E'\sube E$ ，使得每个顶点在 $E'$ 中恰好出现一次。

记 $n=|V_1|=|V_2|$，用集合 $[n]$ 标识这两个集合，可以把 $E'$ 看作是一个排列 $\sigma:[n]\rightarrow[n]$，映射每个 $i\in[n]$ 到一个唯一的 $j\in[n]$，使得 $\overline{ij}\in E'$。令 $X$ 是一个 $n\times n$ 的实变量（？）矩阵，如果边 $\overline{ij}\in E$，则 $X_{i,j}$ 等于变量 $x_{i,j}$，否则 $X_{i,j}$ 等于 0。一个矩阵 $A$ 的行列式定义如下：

<img src="note.assets/image-20210509123241893.png" alt="image-20210509123241893" style="zoom: 50%;" />

其中 $S_n$ 是 $[n]$ 所有排列的集合，$sgn(\sigma)$ 由 $\sigma$ 中逆序数的奇偶决定，当逆序数为偶数时为 $-1$，奇数时为 $+1$。因此 ${\rm det}(X)$ 是一个变量为 $\{x_{i,j}\}_{\overline{ij}\in E}$ $n$ 次多项式，并且对每个完备匹配都有一个对应的项。也即如果 $G$ 有完备匹配当且仅当 $det(X)$ 不是恒等于零的多项式。

由 Lemma 7.5，可以得到算法：从 $[2n]$ 中为 $x_{i,j}$ 选择值，在 $X$ 中替换并计算行列式，如果行列式非零，则判定输入的图有完备匹配，否则判定无。对于一个无完备匹配的图，结果一定为零；而对于一个存在完美匹配的图，结果不为零的概率大于等于 $1-\frac{n}{2n}=\frac{1}{2}$，因为多项式中次数最多为 $n$。

## 7.3 单边错误和“零边错误”：${\bf RP}$，${\bf coRP}$，${\bf ZPP}$

## 7.4 定义的稳健性

## 7.6 随机规约

## 7.7 空间有界的随机计算

